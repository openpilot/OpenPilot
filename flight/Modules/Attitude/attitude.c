/**
 ******************************************************************************
 * @addtogroup OpenPilotModules OpenPilot Modules
 * @{
 * @addtogroup Attitude Copter Control Attitude Estimation
 * @brief Acquires sensor data and computes attitude estimate
 * Specifically updates the the @ref AttitudeActual "AttitudeActual" and @ref AttitudeRaw "AttitudeRaw" settings objects
 * @{
 *
 * @file       attitude.c
 * @author     The OpenPilot Team, http://www.openpilot.org Copyright (C) 2010.
 * @brief      Module to handle all comms to the AHRS on a periodic basis.
 *
 * @see        The GNU Public License (GPL) Version 3
 *
 ******************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * Input objects: None, takes sensor data via pios
 * Output objects: @ref AttitudeRaw @ref AttitudeActual
 *
 * This module computes an attitude estimate from the sensor data
 *
 * The module executes in its own thread.
 *
 * UAVObjects are automatically generated by the UAVObjectGenerator from
 * the object definition XML file.
 *
 * Modules have no API, all communication to other modules is done through UAVObjects.
 * However modules may use the API exposed by shared libraries.
 * See the OpenPilot wiki for more details.
 * http://www.openpilot.org/OpenPilot_Application_Architecture
 *
 */

#include "pios.h"
#include "sensordrift.h"
#include "sensorfetch.h"
#include "attitude.h"
#include "gyros.h"
#include "accels.h"
#include "attitudeactual.h"
#include "attitudesettings.h"
#include "flightstatus.h"
#include "manualcontrolcommand.h"
#include "CoordinateConversions.h"
#include <pios_board_info.h>

#include "positionactual.h"
#include "velocityactual.h"
#include "gpsposition.h"
#include "gpsvelocity.h"
#include "hwsettings.h"
#include "homelocation.h"
#if defined(PIOS_GPS_PROVIDES_AIRSPEED)
#include "gps_airspeed.h"
#endif
 
// Private constants
#define STACK_SIZE_BYTES 800
#define TASK_PRIORITY (tskIDLE_PRIORITY+3)

#define SENSOR_PERIOD 4
#define LOOP_RATE_MS  25.0f
#define GRAV         -9.805f
#define DEG2RAD       (3.141592654f/180.0f)
#define RAD2DEG       (180.0f/3.141592654f)

#define PI_MOD(x) (fmod(x + M_PI, M_PI * 2) - M_PI)
// Private types

// Private variables
static xTaskHandle taskHandle;
static xQueueHandle gyro_queue;

static bool gpsNew_flag;
static HomeLocationData homeLocation;
struct GlobalAttitudeVariables *glbl;

// For running trim flights
uint16_t const MAX_TRIM_FLIGHT_SAMPLES = 65535;


// Private functions
static void AttitudeTask(void *parameters);
static int32_t updateSensors(AccelsData * accelsData, GyrosData * gyrosData, bool cc3d_flag);
static void updateAttitude(float * gyros, float dT);
static void settingsUpdatedCb(UAVObjEvent * objEv);

static int32_t LLA2NED(int32_t LL[2], float altitude, float geoidSeparation, float * NED);
static void HomeLocationUpdatedCb(UAVObjEvent * objEv);
static void GPSPositionUpdatedCb(UAVObjEvent * objEv);


/**
 * Initialise the module, called on startup
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t AttitudeStart(void)
{
	
	// Start main task
	xTaskCreate(AttitudeTask, (signed char *)"Attitude", STACK_SIZE_BYTES/4, NULL, TASK_PRIORITY, &taskHandle);
	TaskMonitorAdd(TASKINFO_RUNNING_ATTITUDE, taskHandle);
	PIOS_WDG_RegisterFlag(PIOS_WDG_ATTITUDE);
	
	return 0;
}

/**
 * Initialise the module, called on startup
 * \returns 0 on success or -1 if initialisation failed
 */
int32_t AttitudeInitialize(void)
{
	AttitudeActualInitialize();
	AttitudeSettingsInitialize();
	AccelsInitialize();
	GyrosInitialize();
	
	PositionActualInitialize();
	VelocityActualInitialize();
	GPSPositionInitialize();
	GPSVelocityInitialize();
	HomeLocationInitialize();

	gpsNew_flag=false;
	glbl=(struct GlobalAttitudeVariables*) pvPortMalloc(sizeof(struct GlobalAttitudeVariables));
	
	// Initialize quaternion
	AttitudeActualData attitude;
	AttitudeActualGet(&attitude);
	attitude.q1 = 1;
	attitude.q2 = 0;
	attitude.q3 = 0;
	attitude.q4 = 0;
	AttitudeActualSet(&attitude);
	
	//--------
	// If bootloader runs, cannot trust the global values to init to 0.
	//--------
	memset(glbl->gyro_correct_int, 0, sizeof(glbl->gyro_correct_int));
	
	glbl->q[0] = 1;
	glbl->q[1] = 0;
	glbl->q[2] = 0;
	glbl->q[3] = 0;
	for(uint8_t i = 0; i < 3; i++)
		for(uint8_t j = 0; j < 3; j++)
			glbl->Rsb[i][j] = 0;
	
	glbl->trim_requested = false;
	
	AttitudeSettingsConnectCallback(&settingsUpdatedCb);
	
	HomeLocationConnectCallback(&HomeLocationUpdatedCb);
	GPSPositionConnectCallback(&GPSPositionUpdatedCb);

	
	return 0;
}

MODULE_INITCALL(AttitudeInitialize, AttitudeStart)

/**
 * Module thread, should not return.
 */
 
int32_t accel_test;
int32_t gyro_test;
static void AttitudeTask(void *parameters)
{
	uint8_t init = 0;
	AlarmsClear(SYSTEMALARMS_ALARM_ATTITUDE);
	
	// Set critical error and wait until the accel is producing data
	//THIS IS BOARD SPECIFIC AND DOES NOT BELONG HERE. Can we put it in #if defined(PIOS_INCLUDE_ADXL345)?
	while(PIOS_ADXL345_FifoElements() == 0) {
		AlarmsSet(SYSTEMALARMS_ALARM_ATTITUDE, SYSTEMALARMS_ALARM_CRITICAL);
		PIOS_WDG_UpdateFlag(PIOS_WDG_ATTITUDE);
	}
	
	const struct pios_board_info * bdinfo = &pios_board_info_blob;
	
	//Test if board is CopterControl or CC3D
	bool cc3d_flag = (bdinfo->board_rev == 0x02);
	
	if(cc3d_flag)
		glbl->gyroGain_ref=1.0f;
	else
		glbl->gyroGain_ref=0.42f;
	
	AttitudeSettingsGyroGainSet(&glbl->gyroGain_ref);	

	// Force settings update to make sure rotation snf home location loaded
	settingsUpdatedCb(AttitudeSettingsHandle());
	HomeLocationUpdatedCb(HomeLocationHandle());
	
	if(cc3d_flag) {
#if defined(PIOS_INCLUDE_MPU6000)
		gyro_test = PIOS_MPU6000_Test();
#endif
	} else {
#if defined(PIOS_INCLUDE_ADXL345)
		accel_test = PIOS_ADXL345_Test();
#endif

#if defined(PIOS_INCLUDE_ADC)
		// Create queue for passing gyro data, allow 2 back samples in case
		gyro_queue = xQueueCreate(1, sizeof(float) * 4);
		PIOS_Assert(gyro_queue != NULL);
		PIOS_ADC_SetQueue(gyro_queue);
		PIOS_ADC_Config((PIOS_ADC_RATE / 1000.0f) * LOOP_RATE_MS);
#endif

	}

	float groundTemperature;
	
	//Grab temperature at bootup. The hope is that the temperature is close enough to real temperature to have a reasonable density altitude estimate
	{
		float prelim_accels[4];
		float prelim_gyros[4];
		if(cc3d_flag){
			getSensorsCC3D(prelim_accels, prelim_gyros);
		}
		else {
			getSensorsCC(prelim_accels, prelim_gyros, &gyro_queue);
		}
		
		groundTemperature=prelim_accels[3];
	}
	
	//Store the original filter specs. This is because we currently have a poor way of calibrating the Premerlani approach
	uint8_t originalFilter=glbl->filter_choice;
	
	// ----------------------------- //
	// Main module loop. Never exits //
	// ----------------------------- //
	while (1) {
		FlightStatusData flightStatus;
		FlightStatusGet(&flightStatus);
		
		//Change gyro calibration parameters...
		if((xTaskGetTickCount() > 1000) && (xTaskGetTickCount() < 7000)) { //...during first 7 seconds or so...
			// For first 7 seconds use accels to get gyro bias
			glbl->accelKp = 1;
			glbl->accelKi = 0.9;
			glbl->yawBiasRate = 0.23;
			init = 0;
			
			//Force to use the CCC, because of the way it calibrates
			glbl->filter_choice=ATTITUDESETTINGS_FILTERCHOICE_CCC;
		}
		else if (glbl->zero_during_arming && (flightStatus.Armed == FLIGHTSTATUS_ARMED_ARMING)) { //...during arming...
			glbl->accelKp = 1;
			glbl->accelKi = 0.9;
			glbl->yawBiasRate = 0.23;
			init = 0;
			
			//Force to use the CCC, because of the way it calibrates
			glbl->filter_choice=ATTITUDESETTINGS_FILTERCHOICE_CCC;
		} else if (init == 0) { //...once fully armed.
			// Reload settings (all the rates)
			AttitudeSettingsAccelKiGet(&glbl->accelKi);
			AttitudeSettingsAccelKpGet(&glbl->accelKp);
			AttitudeSettingsYawBiasRateGet(&glbl->yawBiasRate);
			
			glbl->filter_choice=originalFilter;
			
			init = 1;
		}		
		PIOS_WDG_UpdateFlag(PIOS_WDG_ATTITUDE);

		AccelsData accels;
		GyrosData gyros;
		int8_t retval = 0;

		//Get sensor data, rotate, filter, and output to UAVO. This is the function that calls the wait structures that limit the loop rate
		retval = updateSensors(&accels, &gyros, cc3d_flag);

		
		// Only update attitude when sensor data is good
		if (retval != 0 || cc3d_flag==false) // <--CC IS NOT CURRENTLY SUPPORTED BY NAV BRANCH. FORCE AN ALARM STATE.
			AlarmsSet(SYSTEMALARMS_ALARM_ATTITUDE, SYSTEMALARMS_ALARM_ERROR);
		else {
			// Do not update attitude data in simulation mode
			if (!AttitudeActualReadOnly()){
				float delT;
				portTickType thisSysTime = xTaskGetTickCount();
				static portTickType lastSysTime = 0;
				
				delT = (thisSysTime == lastSysTime) ? 0.001 : (portMAX_DELAY & (thisSysTime - lastSysTime)) / portTICK_RATE_MS / 1000.0f;
				lastSysTime = thisSysTime;
				
				//Update sensor estimation with drift PI feedback
				if(glbl->bias_correct_gyro) { 
					updateSensorDrift(&accels, &gyros, delT);
				}
//				applyDrift(&accels, &gyros);
				
				//Update UAVOs with most accurate sensor data
				AccelsSet(&accels);
				GyrosSet(&gyros);
				
//				float gyrosVec[3] = {gyros.x, gyros.y, gyros.z};
				updateAttitude(&gyros.x, delT);
			}
			
			AlarmsClear(SYSTEMALARMS_ALARM_ATTITUDE);
		}
		
		
		/*=========================*/
		
		if( gpsNew_flag == true){
			
			uint8_t gpsStatus;
			GPSPositionStatusGet(&gpsStatus);
			if (gpsStatus == GPSPOSITION_STATUS_FIX3D) {
				//Load UAVOs
				GPSVelocityData gpsVelocityData;
				GPSVelocityGet(&gpsVelocityData);
				
				PositionActualData positionActualData;
				VelocityActualData velocityActualData;
				
				PositionActualGet(&positionActualData);
				VelocityActualGet(&velocityActualData);
				
				//Get NED coordinates from GPS lat-lon
				float gps_NED[3];
				
				int32_t LL_int[2];
				int32_t tmpVal;
				GPSPositionLatitudeGet(&tmpVal);
				LL_int[0]=tmpVal;
				GPSPositionLongitudeGet(&tmpVal);
				LL_int[1]=tmpVal;
				
				float altitude;
				GPSPositionAltitudeGet(&altitude);
				
				float geoidSeparation;
				GPSPositionGeoidSeparationGet(&geoidSeparation);
				
				LLA2NED(LL_int, altitude, geoidSeparation, gps_NED);
				
				//Calculate filter coefficients
				float dT=.100f;
				float tauPosNorthEast=0.3f;
				float tauPosDown=0.5f;
				float tauVelNorthEast=0.01f;
				float tauVelDown=0.1f;
				float alphaPosNorthEast=dT/(dT + tauPosNorthEast);
				float alphaPosDown=dT/(dT + tauPosDown);
				float alphaVelNorthEast=dT/(dT + tauVelNorthEast);
				float alphaVelDown=dT/(dT + tauVelDown);
				
				//Low pass filter for velocity
				velocityActualData.North=(1-alphaVelNorthEast)*velocityActualData.North + alphaVelNorthEast*gpsVelocityData.North;
				velocityActualData.East= (1-alphaVelNorthEast)*velocityActualData.East + alphaVelNorthEast*gpsVelocityData.East;
				velocityActualData.Down= (1-alphaVelDown)*velocityActualData.Down + alphaVelDown*gpsVelocityData.Down;
				
				//Complementary filter for position
				positionActualData.North=(1-alphaPosNorthEast)*(positionActualData.North+(velocityActualData.North*dT)) + alphaPosNorthEast*gps_NED[0];
				positionActualData.East= (1-alphaPosNorthEast)*(positionActualData.East+(velocityActualData.East*dT)) + alphaPosNorthEast*gps_NED[1];
				positionActualData.Down= (1-alphaPosDown)*(positionActualData.Down+(velocityActualData.Down*dT)) + alphaPosDown*gps_NED[2];

				//Very slowly use GPS heading data to converge. This is a poor way of doing things, but will work in the short term for testing.
				if (fabs(velocityActualData.North) > 3.0f){ //Instead of calculating norm, use a gauge approach
					if (fabs(velocityActualData.North) > 4.0f || fabs(velocityActualData.East) > 3.0f){
						float heading=atan2f(velocityActualData.East, velocityActualData.North);
						
						AttitudeActualData attitudeActual;
						AttitudeActualGet(&attitudeActual);
						
						while(heading-attitudeActual.Yaw < -180.0f){
							heading+=360.0f;
						}
						while(heading-attitudeActual.Yaw > 180.0f){
							heading-=360.0f;
						}
						
						attitudeActual.Yaw=.9f*attitudeActual.Yaw+0.1f*heading;
						
						// Convert into quaternions degrees (makes assumptions about RPY order)
						RPY2Quaternion(&attitudeActual.Roll, &attitudeActual.q1);
						
						//BOOOOOOOOOOOOOOO----------VVVVVVVVVV
						
						if (!AttitudeActualReadOnly()){
							AttitudeActualSet(&attitudeActual);
						}
					}
				}
				
				//Get airspeed
#if defined(PIOS_GPS_PROVIDES_AIRSPEED)
				float staticPressure=101325.0f * powf(1.0f - 2.2555e-5f * (homeLocation.Altitude-positionActualData.Down), 5.25588f); //http://www.engineeringtoolbox.com/air-altitude-pressure-d_462.html
				float staticAirDensity=0.003483613507536f*staticPressure/(groundTemperature + 273.15f); //rho = PM/RT
				
				gps_airspeed_update(&gpsVelocityData, staticAirDensity);
#endif				
				
				// Do not update position and velocity estimates when in simulation mode
				if (!PositionActualReadOnly()){
					PositionActualSet(&positionActualData);
				}
				if (!VelocityActualReadOnly()){
					VelocityActualSet(&velocityActualData);
				}
			}
			
			gpsNew_flag=false;
		}
 
	}
}

float gyros_passed[3];

/**
 * Get an update from the sensors
 * @param[in] attitudeRaw Populate the UAVO instead of saving right here
 * @return 0 if successfull, -1 if not
 */
static int32_t updateSensors(AccelsData * accels, GyrosData * gyros, bool cc3d_flag){
	int8_t retval;
	float prelim_accels[4];
	float prelim_gyros[4];
	if(cc3d_flag){
		retval=getSensorsCC3D(prelim_accels, prelim_gyros);
	}
	else {
		retval=getSensorsCC(prelim_accels, prelim_gyros, &gyro_queue);
	}
	
	if (retval < 0) { //No sensor data!
		return retval;
	}
	
	//Rotate sensor board into body frame
	if(glbl->rotate){
		float tmpVec[3];
		
		//Rotate the vector into a temporary vector, and then copy back into the original vectors.
		rot_mult(glbl->Rsb, prelim_accels, tmpVec, false);
		memcpy(prelim_accels, tmpVec, sizeof(tmpVec));
		
		rot_mult(glbl->Rsb, prelim_gyros,  tmpVec, false);
		memcpy(prelim_gyros,  tmpVec, sizeof(tmpVec));
	}
	
	//Correct accels biases. 
	// NOTE: At this point, prelim_accels has now been rotated into the body frame
	accels->x = prelim_accels[0];
	accels->y = prelim_accels[1];
	accels->z = prelim_accels[2];
	
	//Correct gyroscope biases. 
	// NOTE: At this point, prelim_gyros has now been rotated into the body frame, as are the gyro biases
	if(glbl->bias_correct_gyro) { 
		// Applying integral component here so it can be seen on the gyros and correct bias
		gyros->x = prelim_gyros[0] + glbl->gyro_correct_int[0];
		gyros->y = prelim_gyros[1] + glbl->gyro_correct_int[1];
		gyros->z = prelim_gyros[2] + glbl->gyro_correct_int[2];
	}
	else {
		gyros->x = prelim_gyros[0];
		gyros->y = prelim_gyros[1];
		gyros->z = prelim_gyros[2];
		
	}
	
	
	//CopterControl has a function which can generate on the fly a correct hovering accelerometer bias for
	//quadcopters and helicopters. See more on the wiki and forums: ???
	if (glbl->trim_requested) {
		if (glbl->trim_samples >= MAX_TRIM_FLIGHT_SAMPLES) {
			glbl->trim_requested = false;
		} else {
			uint8_t armed;
			float throttle;
			FlightStatusArmedGet(&armed);
			ManualControlCommandThrottleGet(&throttle);  // Until flight status indicates airborne
//			if ((armed == FLIGHTSTATUS_ARMED_ARMED) && (throttle > 0)) {
				glbl->trim_samples++;
				// Store the digitally scaled version since that is what we use for bias
				glbl->trim_accels[0] += accels->x;
				glbl->trim_accels[1] += accels->y;
				glbl->trim_accels[2] += accels->z;
//			}
		}
	}
	
	return 0;
	
}

static void updateAttitude(float * gyros, float dT)
{
	
	{ // scoping variables to save memory
		// Work out time derivative from INSAlgo writeup
		// Also accounts for the fact that gyros are in deg/s
		float qdot[4];
		qdot[0] = (-glbl->q[1] * gyros[0] - glbl->q[2] * gyros[1] - glbl->q[3] * gyros[2]) * dT * M_PI / 180 / 2;
		qdot[1] = (glbl->q[0] * gyros[0] - glbl->q[3] * gyros[1] + glbl->q[2] * gyros[2]) * dT * M_PI / 180 / 2;
		qdot[2] = (glbl->q[3] * gyros[0] + glbl->q[0] * gyros[1] - glbl->q[1] * gyros[2]) * dT * M_PI / 180 / 2;
		qdot[3] = (-glbl->q[2] * gyros[0] + glbl->q[1] * gyros[1] + glbl->q[0] * gyros[2]) * dT * M_PI / 180 / 2;
		
		// Integrate a time step
		glbl->q[0] = glbl->q[0] + qdot[0];
		glbl->q[1] = glbl->q[1] + qdot[1];
		glbl->q[2] = glbl->q[2] + qdot[2];
		glbl->q[3] = glbl->q[3] + qdot[3];
		
		if(glbl->q[0] < 0) {
			glbl->q[0] = -glbl->q[0];
			glbl->q[1] = -glbl->q[1];
			glbl->q[2] = -glbl->q[2];
			glbl->q[3] = -glbl->q[3];
		}
	}
	
	// Renomalize
	float qmag = sqrtf(powf(glbl->q[0],2.0f) + powf(glbl->q[1],2.0f) + powf(glbl->q[2],2.0f) + powf(glbl->q[3],2.0f));
	glbl->q[0] = glbl->q[0] / qmag;
	glbl->q[1] = glbl->q[1] / qmag;
	glbl->q[2] = glbl->q[2] / qmag;
	glbl->q[3] = glbl->q[3] / qmag;
	
	// If quaternion has become inappropriately short or is nan reinit.
	// THIS SHOULD NEVER ACTUALLY HAPPEN
	if((fabs(qmag) < 1e-3) || (qmag != qmag)) {
		glbl->q[0] = 1;
		glbl->q[1] = 0;
		glbl->q[2] = 0;
		glbl->q[3] = 0;
	}
	
	AttitudeActualData attitudeActual;
	AttitudeActualGet(&attitudeActual);
	
	quat_copy(glbl->q, &attitudeActual.q1);
	
	// Convert into eueler degrees (makes assumptions about RPY order)
	Quaternion2RPY(&attitudeActual.q1,&attitudeActual.Roll);
	
	AttitudeActualSet(&attitudeActual);
}

static void settingsUpdatedCb(UAVObjEvent * objEv) {
	AttitudeSettingsData attitudeSettings;
	AttitudeSettingsGet(&attitudeSettings);
	
	glbl->accelKp = attitudeSettings.AccelKp;
	glbl->accelKi = attitudeSettings.AccelKi;
	glbl->yawBiasRate = attitudeSettings.YawBiasRate;
	glbl->gyroGain[0] = glbl->gyroGain[1] = glbl->gyroGain[2] = glbl->gyroGain_ref = attitudeSettings.GyroGain;		
	
	glbl->zero_during_arming = (attitudeSettings.ZeroDuringArming == ATTITUDESETTINGS_ZERODURINGARMING_TRUE);
	glbl->bias_correct_gyro = (attitudeSettings.BiasCorrectGyro == ATTITUDESETTINGS_BIASCORRECTGYRO_TRUE);
	glbl->filter_choice = attitudeSettings.FilterChoice;
	
	//The accelerometer sensor calibration values are all in the board sensor frame.
	glbl->accelbias[0] = attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_X_S]/1000.0f; //Divide by 1000 because `accelbias` is in units
	glbl->accelbias[1] = attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_Y_S]/1000.0f; // of 1000*[m/s^2]
	glbl->accelbias[2] = attitudeSettings.AccelBias[ATTITUDESETTINGS_ACCELBIAS_Z_S]/1000.0f;

	glbl->accelscale[0] = attitudeSettings.AccelScale[ATTITUDESETTINGS_ACCELSCALE_X_S]/10000.0f; //Divide by 1000 because `accelbias` is in units
	glbl->accelscale[1] = attitudeSettings.AccelScale[ATTITUDESETTINGS_ACCELSCALE_Y_S]/10000.0f; // of 1000*[m/s^2]
	glbl->accelscale[2] = attitudeSettings.AccelScale[ATTITUDESETTINGS_ACCELSCALE_Z_S]/10000.0f;

	//Provide minimum for scale. This keeps the accels from accidentally being "turned off".
	for (int i=0; i<3; i++){
		if (glbl->accelscale[i] <.001f) {
			glbl->accelscale[i]=.001f;
		}
	}
	
	
	//The gyroscope sensor calibration values are all in the body frame.
	glbl->gyro_correct_int[0] = attitudeSettings.GyroBias[ATTITUDESETTINGS_GYROBIAS_X_B] / 100.0f; //Divide by 100 because `GyroBias` 
	glbl->gyro_correct_int[1] = attitudeSettings.GyroBias[ATTITUDESETTINGS_GYROBIAS_Y_B] / 100.0f; // is in units of 100*[deg/s]
	glbl->gyro_correct_int[2] = attitudeSettings.GyroBias[ATTITUDESETTINGS_GYROBIAS_Z_B] / 100.0f;
	
	//Calculate sensor to board rotation matrix. If the matrix is the identity, don't expend cycles on rotation
	if(attitudeSettings.BoardRotation[0] == 0 && attitudeSettings.BoardRotation[1] == 0 &&
	   attitudeSettings.BoardRotation[2] == 0) {
		glbl->rotate = false;
		
		// Shouldn't need to be used, but just to be safe we will anyway
		float rotationQuat[4] = {1,0,0,0};
		Quaternion2R(rotationQuat, glbl->Rsb);
	} else {
		float rpy[3] = {attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_ROLL]*DEG2RAD/100.0f,
			attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_PITCH]*DEG2RAD/100.0f,
			attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_YAW]*DEG2RAD/100.0f};
		Euler2R(rpy, glbl->Rsb);
		glbl->rotate = true;
	}
	
	if (attitudeSettings.TrimFlight == ATTITUDESETTINGS_TRIMFLIGHT_START) {
		glbl->trim_accels[0] = 0;
		glbl->trim_accels[1] = 0;
		glbl->trim_accels[2] = 0;
		glbl->trim_samples = 0;
		glbl->trim_requested = true;
	} else if (attitudeSettings.TrimFlight == ATTITUDESETTINGS_TRIMFLIGHT_LOAD) {
		glbl->trim_requested = false;

		//Get sensor data  mean 
		float a_body[3]={glbl->trim_accels[0]/glbl->trim_samples, glbl->trim_accels[1]/glbl->trim_samples, glbl->trim_accels[2]/glbl->trim_samples};
		
		//Inverse rotation of sensor data, from body frame into sensor frame
		float a_sensor[3];
		rot_mult(glbl->Rsb, a_body, a_sensor, true);
		
		//Temporary variables
		float psi, theta, phi;
		
		psi=attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_YAW]*DEG2RAD/100.0f;
		
		float cP=cosf(psi);
		float sP=sinf(psi);

		//In case psi is too small, we have to use a different equation to solve for theta
		if (fabs(psi) > 3.1415f/2)
			theta=atanf((a_sensor[1]+cP*(sP*a_sensor[0]-cP*a_sensor[1]))/(sP*a_sensor[2]));
		else
			theta=atanf((a_sensor[0]-sP*(sP*a_sensor[0]-cP*a_sensor[1]))/(cP*a_sensor[2]));
			
		phi=atan2f((sP*a_sensor[0]-cP*a_sensor[1])/GRAV,(a_sensor[2]/cosf(theta)/GRAV));
		
		attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_ROLL]  = phi*RAD2DEG*100.0f;
		attitudeSettings.BoardRotation[ATTITUDESETTINGS_BOARDROTATION_PITCH] = theta*RAD2DEG*100.0f;

		attitudeSettings.TrimFlight = ATTITUDESETTINGS_TRIMFLIGHT_NORMAL;
		AttitudeSettingsSet(&attitudeSettings);
	} else {
		glbl->trim_requested = false;
	}

}

/**
 * @brief Convert the GPS LLA position into NED coordinates
 * @note this method uses a taylor expansion around the home coordinates
 * to convert to NED which allows it to be done with all floating
 * calculations
 * @param[in] Current GPS coordinates, (Lat, Lon, Alt)
 * @param[out] NED frame coordinates
 * @returns 0 for success, -1 for failure
 */
float T[3];

static int32_t LLA2NED(int32_t LL[2], float altitude, float geoidSeparation, float * NED)
{
	float dL[3] = {(LL[0] - homeLocation.Latitude) / 10.0e6f * DEG2RAD,
		(LL[1] - homeLocation.Longitude) / 10.0e6f * DEG2RAD,
		(altitude + geoidSeparation - homeLocation.Altitude)};
	
	NED[0] = T[0] * dL[0];
	NED[1] = T[1] * dL[1];
	NED[2] = T[2] * dL[2];
	
	return 0;
}

static void GPSPositionUpdatedCb(UAVObjEvent * objEv) 
{
	gpsNew_flag=true;	
}

static void HomeLocationUpdatedCb(UAVObjEvent * objEv) 
{
	float lat, alt;
	
	HomeLocationGet(&homeLocation);
	
	// Compute vector for converting deltaLLA to NED
	lat = homeLocation.Latitude / 10.0e6f * DEG2RAD;
	alt = homeLocation.Altitude;
	
	T[0] = alt+6.378137E6f;
	T[1] = cosf(lat)*(alt+6.378137E6f);
	T[2] = -1.0f;
	
	//Set NED coordinates relative to the new home location
	uint8_t gpsStatus;
	GPSPositionStatusGet(&gpsStatus);
	if (gpsStatus == GPSPOSITION_STATUS_FIX3D) //NEED A BETTER TEST THAN THIS
	{
		float NED[3];
		
		int32_t LL_int[2];
		int32_t tmpVal;
		GPSPositionLatitudeGet(&tmpVal);
		LL_int[0]=tmpVal;
		GPSPositionLongitudeGet(&tmpVal);
		LL_int[1]=tmpVal;
		
		float altitude;
		GPSPositionAltitudeGet(&altitude);
		
		float geoidSeparation;
		GPSPositionGeoidSeparationGet(&geoidSeparation);
		
		LLA2NED(LL_int, altitude, geoidSeparation, NED);
		
		PositionActualData positionActualData;
		positionActualData.North=NED[0];
		positionActualData.East=NED[1];
		positionActualData.Down=NED[2];
		
		PositionActualSet(&positionActualData);
	}
	
	//Refuse to set gravity lower than Mars's gravity or greater than Jupiter's. Assume that if there was an attempt to do this, it was mistaken, and reset gravity to normal.
	if (homeLocation.g_e < 3 || homeLocation.g_e > 25) {
		homeLocation.g_e=9.805;
		HomeLocationSet(&homeLocation);
	}
}


/**
 * @}
 * @}
 */
