/**
 ******************************************************************************
 * @addtogroup OpenPilotModules OpenPilot Modules
 * @{
 * @addtogroup Attitude Copter Control Attitude Estimation
 * @brief A collection of mathematics that help reduce sensor drift. Pick and choose for best performance
 * @{
 *
 * @file       sensordrift.c
 * @author     The OpenPilot Team, http://www.openpilot.org Copyright (C) 2010.
 * @brief      Module to handle all comms to the AHRS on a periodic basis.
 *
 * @see        The GNU Public License (GPL) Version 3
 *
 ******************************************************************************/
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * UAVObjects are automatically generated by the UAVObjectGenerator from
 * the object definition XML file.
 *
 * Modules have no API, all communication to other modules is done through UAVObjects.
 * However modules may use the API exposed by shared libraries.
 * See the OpenPilot wiki for more details.
 * http://www.openpilot.org/OpenPilot_Application_Architecture
 *
 */

#include "pios.h"
#include "hwsettings.h"
#include <pios_board_info.h>
#include "sensordrift.h"
#include "CoordinateConversions.h"

#include "state.h"
#include "attitudesettings.h"
#include "gpsvelocity.h"
#include "manualcontrolcommand.h"
#if defined (PIOS_INCLUDE_MAGNETOMETER) //THIS PIOS DEFINE DOES NOT CURRENTLY EXIST, BUT WE SHOULD ADD IT IN ORDER TO SUPPORT ALL MAGS, NOT JUST THE HMC5883
 #include "magnetometer.h"
#endif
#if defined (PIOS_GPS_PROVIDES_AIRSPEED) //THIS PIOS DEFINE DOES NOT CURRENTLY EXIST, BUT WE SHOULD ADD IT IN ORDER TO SUPPORT ALL MAGS, NOT JUST THE HMC5883
 #include "airspeedactual.h"
#endif

//Global variables
extern struct GlobalAttitudeVariables *glblAtt;
bool firstpass_flag=true;

struct GlobalDcmDriftVariables {
//	float gyros_passed[3];
	float GPSV_old[3];
	
	float accels_e_integrator[3];
	float omegaCorrI[3];
	
	bool gpsPresent_flag;
	volatile uint8_t gpsVelocityDataConsumption_flag;
	bool magNewData_flag;
	
	float accelsKp;
	float rollPitchKp;
	float rollPitchKi;
	float yawKp;
	float yawKi;
	float gyroCalibTau;
	float delT_between_GPS;
	
};

#define GPS_UNCONSUMED       0x00
#define GPS_CONSUMED_BY_RPY  0x01
#define GPS_CONSUMED_BY_Y    0x02
#define GPS_CONSUMED         0xFF

static struct GlobalDcmDriftVariables * drft;

// Private constants

// Private types

// Private variables
#define GRAV -9.805f

//#define DRIFT_TYPE CCC
enum DRIFT_CORRECTION_ALGOS {
	CCC,
	PREMERLANI
};

// Private functions
void rollPitch_drift_GPS(float Rbe[3][3], float accels_e_int[3], float delT, float *errRollPitch_b);
void gyro_drift(float gyro[3], float errYaw_b[3], float errRollPitch_b[3], float normOmegaScalar, float delT, float *omegaCorrP, float *omegaCorrI);
void yaw_drift_MagGPS(float Rbe[3][3], bool gpsNewData_flag, bool magNewData_flag, float *errYaw_b);
void calibrate_gyros_high_speed(float gyro[3], float omegaCorrP[3], float normOmegaScalar, float delT, float *ggain);
void rollPitch_drift_accel(float accels[3], float gyros[3], float Rbe[3][3], float airspeed_tas, float *errRollPitch_b);

//static void DCMSettingsUpdatedCb(UAVObjEvent * objEv);
static void GPSVelocityUpdatedCb(UAVObjEvent * objEv);
#if defined (PIOS_INCLUDE_MAGNETOMETER)
static void MagnetometerUpdatedCb(UAVObjEvent * objEv);
#endif

void updateSensorDrift(AccelsData * accelsData, GyrosData * gyrosData, const float delT){
	// Bad practice to assume structure order, but saves memory. //WHY DOES THIS SAVE MEMORY?
	float * gyros = &gyrosData->x;
	float * accels = &accelsData->x;	
	
	if (glblAtt->filter_choice==ATTITUDESETTINGS_FILTERCHOICE_CCC) {
			CottonComplementaryCorrection(accels, gyros, delT);
	}
	else if(glblAtt->filter_choice==ATTITUDESETTINGS_FILTERCHOICE_PREMERLANI || glblAtt->filter_choice==ATTITUDESETTINGS_FILTERCHOICE_PREMERLANI_GPS){	
		if (firstpass_flag){
			
//			HwSettingsInitialize(); //SHOULD THIS BE COMMENTED OUT OR NOT?
			uint8_t optionalModules[HWSETTINGS_OPTIONALMODULES_NUMELEM];
			HwSettingsOptionalModulesGet(optionalModules);
			
			
			//Allocate memory for DCM drift globals
			drft = (struct GlobalDcmDriftVariables *) pvPortMalloc(sizeof(struct GlobalDcmDriftVariables));
			
			memset(drft->GPSV_old, 0, sizeof(drft->GPSV_old));
			memset(drft->omegaCorrI, 0, sizeof(drft->omegaCorrI));
			memset(drft->accels_e_integrator, 0, sizeof(drft->accels_e_integrator));
			
//			//Create and connect queue
//			DCMSettingsConnectCallback(DCMSettingsUpdatedCb);
//
//			//Force callback in order to seed initial values
//			DCMSettingsUpdatedCb(DCMSettingsHandle());

/*VVVVVVVVVVVVVVVVVVVVVVV*/			
/* WHAT??? HARD CODED VARIABLES BECAUSE I'VE BEEN TOO LAZY TO ADD THEM TO THE UAVO? */
			drft->accelsKp = 1;
			drft->rollPitchKp = 20;
			drft->rollPitchKi = 1;
			drft->yawKp = 0;
			drft->yawKi = 0;
			drft->gyroCalibTau = 100;
/*^^^^^^^^^^^^^^^^^^^^^^^*/
			
			//Set flags
			if (optionalModules[HWSETTINGS_OPTIONALMODULES_GPS] == HWSETTINGS_OPTIONALMODULES_ENABLED && PIOS_COM_GPS) {
				GPSVelocityConnectCallback(GPSVelocityUpdatedCb);
				drft->gpsPresent_flag = true;
				drft->gpsVelocityDataConsumption_flag=GPS_CONSUMED;
			}
			else{
				drft->gpsPresent_flag = false;
			}

#if defined (PIOS_INCLUDE_MAGNETOMETER)
			MagnetometerConnectCallback(MagnetometerUpdatedCb);	
#endif			
			drft->magNewData_flag=false;

			drft->delT_between_GPS=0;
			
			firstpass_flag=false;
		}

		drft->rollPitchKp = glblAtt->accelKp*1000.0f;
		drft->rollPitchKi = glblAtt->accelKi*10000.0f;

		
		//Convert quaternions into rotation matrix
		float Rbe[3][3];
		Quaternion2R(glblAtt->q, Rbe);
		
#if defined (PIOS_INCLUDE_GPS)
		if(glblAtt->filter_choice==ATTITUDESETTINGS_FILTERCHOICE_PREMERLANI_GPS)
		{
			DcmCorrection(accels, gyros, Rbe, delT, true);
		}
		else if(glblAtt->filter_choice==ATTITUDESETTINGS_FILTERCHOICE_PREMERLANI)
#endif
		{
			DcmCorrection(accels, gyros, Rbe, delT, false);
		}
	}
}


/*
 * Correct sensor drift, using the 3C approach from J. Cotton
 */
void CottonComplementaryCorrection(float * accels, float * gyros, const float delT)
{
	float grav_b[3];
	float accel_err_b[3];
	
	// Rotate normalized gravity reference vector to body frame and cross with measured acceleration
	grav_b[0] = -(2 * (glblAtt->q[1] * glblAtt->q[3] - glblAtt->q[0] * glblAtt->q[2]));
	grav_b[1] = -(2 * (glblAtt->q[2] * glblAtt->q[3] + glblAtt->q[0] * glblAtt->q[1]));
	grav_b[2] = -(glblAtt->q[0] * glblAtt->q[0] - glblAtt->q[1]*glblAtt->q[1] - glblAtt->q[2]*glblAtt->q[2] + glblAtt->q[3]*glblAtt->q[3]);
	CrossProduct((const float *) accels, (const float *) grav_b, accel_err_b);
	
	// Account for accel magnitude
	float accel_mag = VectorMagnitude(accels);
	if(accel_mag < 1.0e-3f)
		return;
	
	//Normalize error vector
	accel_err_b[0] /= accel_mag;
	accel_err_b[1] /= accel_mag;
	accel_err_b[2] /= accel_mag;
	
	// Accumulate integral of error.  Scale here so that units are (deg/s) but accelKi has units of s
	glblAtt->gyro_correct_int[0] += accel_err_b[0] * glblAtt->accelKi;
	glblAtt->gyro_correct_int[1] += accel_err_b[1] * glblAtt->accelKi;

	// Because most crafts wont get enough information from gravity to zero yaw gyro, we try
	// and make it average zero (weakly)
	glblAtt->gyro_correct_int[2] += - gyros[2] * glblAtt->yawBiasRate;	
	
	// In this step, correct rates based on proportional error. The integral component is applied in updateSensors
	gyros[0] += accel_err_b[0] * glblAtt->accelKp / delT;
	gyros[1] += accel_err_b[1] * glblAtt->accelKp / delT;
	gyros[2] += accel_err_b[2] * glblAtt->accelKp / delT;
}


#define GPS_SPEED_MIN 5 // Minimum velocity in [m/s]
#define GPS_YAW_KP .1;
#define MAG_YAW_KP .1;

#define MAXIMUM_SPIN_DCM_INTEGRAL 20.0f //in [deg/s]

/*
 * Correct sensor drift, using the DCM approach from W. Premerlani et. al
 */
void DcmCorrection(float * accels, float * gyros, float Rbe[3][3], const float delT, bool GPS_Drift_Compensation)
{
	float errYaw_b[3]={0,0,0};
	float errRollPitch_b[3]={0,0,0};
	float omegaCorrP[3];
	
	float normOmegaScalar = VectorMagnitude(gyros);

	//Output raw gyro data to UAVO
//	DCMStatusData dcmStatus;
//	DCMStatusGet(&dcmStatus);
//	
//	dcmStatus.rawGyros[0]=gyros[0];
//	dcmStatus.rawGyros[1]=gyros[1];
//	dcmStatus.rawGyros[2]=gyros[2];
	
	
	//Correct roll-pitch drift via GPS and accelerometer
	//The math is derived from Roll-Pitch Gyro Drift Compensation, Rev.3, by W. Premerlani
#if defined (PIOS_INCLUDE_GPS)
	if (drft->gpsPresent_flag && GPS_Drift_Compensation){ 		
		float accels_e[3];
		
		//Rotate accelerometer readings into Earth frame. Note that we need to take the transpose of Rbe.
		rot_mult(Rbe, accels, accels_e, TRUE);
		
		//Integrate accelerometer measurements in Earth frame
		drft->accels_e_integrator[0]+=accels_e[0]*delT;
		drft->accels_e_integrator[1]+=accels_e[1]*delT;
		drft->accels_e_integrator[2]+=accels_e[2]*delT;
		
		
		drft->delT_between_GPS+=delT;
		
		//Check if the GPS has new information.
		if(!(drft->gpsVelocityDataConsumption_flag & GPS_CONSUMED_BY_RPY)) {

			//Compute drift correction, errRollPitch_b, from GPS
			rollPitch_drift_GPS(Rbe, drft->accels_e_integrator, drft->delT_between_GPS, errRollPitch_b);
			
			//Reset integrator
			memset(drft->accels_e_integrator, 0, sizeof(drft->accels_e_integrator)); 
			
			//Mark GPS data as consumed by this function
			drft->gpsVelocityDataConsumption_flag|=GPS_CONSUMED_BY_RPY;
			
			drft->delT_between_GPS=0;		
			
		}
	}
#endif

	if (!GPS_Drift_Compensation) {
#if defined (PIOS_INCLUDE_GPS) && 0 || defined (PIOS_INCLUDE_MAGNETOMETER)
		if (!(drft->gpsVelocityDataConsumption_flag & GPS_CONSUMED_BY_Y)) {
			yaw_drift_MagGPS(Rbe, true, drft->magNewData_flag, errYaw_b); //We're actually using new GPS data here, but it's already been stored in old by the previous function
			
			//Mark GPS data as consumed by this function
			drft->gpsVelocityDataConsumption_flag|=GPS_CONSUMED_BY_Y;
		}
		else {
			//In addition to calculating the roll-pitch-yaw error, we can calculate yaw drift, errYaw_b, based on GPS and attitude data
			yaw_drift_MagGPS(Rbe, false, drft->magNewData_flag, errYaw_b); //We're actually using new GPS data here, but it's already been stored in old by the previous function
		}
		
		//Reset flag. Not the best place to do it, but it's messy anywhere else
		if (drft->magNewData_flag){
			drft->magNewData_flag=false;
		}
#endif
		//In addition, we can calculate roll-pitch error with only the aid of an accelerometer
#if defined(PIOS_GPS_PROVIDES_AIRSPEED)
		AirspeedActualData airspeedActualData;
		AirspeedActualGet(&airspeedActualData);
		float airspeed_tas = airspeedActualData.TrueAirspeed;	
#else
		float airspeed_tas = 0;
#endif
		rollPitch_drift_accel(accels, gyros, Rbe, airspeed_tas, errRollPitch_b);
	}
	
	//Calculate gyro drift, based on all errors
	gyro_drift(gyros, errYaw_b, errRollPitch_b, normOmegaScalar, delT, omegaCorrP, drft->omegaCorrI);
	
	
	calibrate_gyros_high_speed(gyros, omegaCorrP, normOmegaScalar, delT, glblAtt->gyroGain);

	//Calculate final drift response
	gyros[0]+=omegaCorrP[0] + drft->omegaCorrI[0];
	gyros[1]+=omegaCorrP[1] + drft->omegaCorrI[1];
	gyros[2]+=omegaCorrP[2] + drft->omegaCorrI[2];

	//Add 0.0001% of proportional error back into gyroscope bias offset. This keeps DC elements out of the raw gyroscope data.
	glblAtt->gyro_correct_int[0]+=omegaCorrP[0]/1000000.0f;
	glblAtt->gyro_correct_int[1]+=omegaCorrP[1]/1000000.0f;
	
	// Because most crafts wont get enough information from gravity to zero yaw gyro, we try
	// and make it average zero (weakly)
	glblAtt->gyro_correct_int[2] += - gyros[2] * glblAtt->yawBiasRate;
	
/*	
	if(1){
		
		dcmStatus.omegaCorrP[0]=drft->gpsVelocityDataConsumption_flag;
		dcmStatus.omegaCorrP[1]=errRollPitch_b[1];
		dcmStatus.omegaCorrP[2]=errRollPitch_b[2];
		
		dcmStatus.omegaCorrI[0]=drft->omegaCorrI[0];
		dcmStatus.omegaCorrI[1]=drft->omegaCorrI[1];
		dcmStatus.omegaCorrI[2]=drft->omegaCorrI[2];
	}
	else if(0){
		dcmStatus.rawGyros[0]=Rbe[0][0];
		dcmStatus.rawGyros[1]=Rbe[0][1];
		dcmStatus.rawGyros[2]=Rbe[0][2];
		
		dcmStatus.omegaCorrP[0]=Rbe[1][0];
		dcmStatus.omegaCorrP[1]=Rbe[1][1];
		dcmStatus.omegaCorrP[2]=Rbe[1][2];

		dcmStatus.omegaCorrI[0]=Rbe[2][0];
		dcmStatus.omegaCorrI[1]=Rbe[2][1];
		dcmStatus.omegaCorrI[2]=Rbe[2][2];
	}
	else{
		dcmStatus.omegaCorrP[0]=glblAtt->gyroGain[0];
		dcmStatus.omegaCorrP[1]=glblAtt->gyroGain[1];
		dcmStatus.omegaCorrP[2]=glblAtt->gyroGain[2];

		dcmStatus.omegaCorrI[0]=glblAtt->gyro_correct_int[0];
		dcmStatus.omegaCorrI[1]=glblAtt->gyro_correct_int[1];
		dcmStatus.omegaCorrI[2]=glblAtt->gyro_correct_int[2];
	}
	
//	dcmStatus.normOmegaScalar=drft->gpsVelocityDataConsumption_flag;
	dcmStatus.normOmegaScalar=drft->delT_between_GPS;
	DCMStatusSet(&dcmStatus);
*/ 
}


/*
 * Calculate the error, as indicated by the accelerometer. It's important to use the true airspeed here, and not CAS or EAS
 */
void 	rollPitch_drift_accel(float accels[3], float gyros[3], float Rbe[3][3], float airspeed_tas, float *errRollPitch_b)
{
	float g_ref[3];
	float errAccelsRollPitch_b[3];
	
	//Fuselage Z vector is simply the Z column of the rotation matrix
	float fuselageZ[3]={Rbe[0][2], Rbe[1][2], Rbe[2][2]};
	
	//Calculate centripetal acceleration
	float acc_centripetal[3]={0, gyros[2]*airspeed_tas, -gyros[1]*airspeed_tas};
	
	//Combine measurements and centripetal accelerations. This should give the gravity reference vector
	g_ref[0]=accels[0]; //Remember that for fixed-wing, acc_centripetal[0] = 0
	g_ref[1]=accels[1] - acc_centripetal[1];
	g_ref[2]=accels[2] - acc_centripetal[2];
	
	//Normalize acceleration vector
	float normG=sqrtf(g_ref[0]*g_ref[0] + g_ref[1]*g_ref[1] + g_ref[2]*g_ref[2]);
	g_ref[0]/=normG;
	g_ref[1]/=normG;
	g_ref[2]/=normG;
	
	//Error is cross product of reference vector and estimated orientation. Reverse operation in order to have correct sign for application to error sum
	CrossProduct((const float *)fuselageZ, (const float *) g_ref, errAccelsRollPitch_b);
	
	//Add errors into global error vector
	errRollPitch_b[0]+=errAccelsRollPitch_b[0]*drft->accelsKp;
	errRollPitch_b[1]+=errAccelsRollPitch_b[1]*drft->accelsKp;
	errRollPitch_b[2]+=errAccelsRollPitch_b[2]*drft->accelsKp;
}


/*
 * This function takes in a number of different error rotations, weights them, and applies
 *  them to the gyroscope readings. In addition, there is a function to increase the correction 
 *  at high speeds in order to keep the gyro from becoming "dizzy".
 */
void gyro_drift(float gyro[3], float errYaw_b[3], float errRollPitch_b[3], float normOmegaScalar, float delT, float *omegaCorrP, float *omegaCorrI)
{
	
	float kpyaw ;
	float kprollpitch ;
	
	// boost the KPs at high spin rate, to compensate for increased error due to calibration error
	// above 50 degrees/second, scale by rotation rate divided by 50. As per Fast Rotations, by William Premerlani.	
	if ( normOmegaScalar < ( 50.0f ))
	{
		kpyaw = drft->yawKp;
		kprollpitch = drft->rollPitchKp ;
	}
	else if ( normOmegaScalar < ( 500.0f ) )
	{
		kpyaw = ( normOmegaScalar / 50.0f ) * drft->yawKp;
		kprollpitch = ( normOmegaScalar / 50.0f ) * drft->rollPitchKp;
	}
	else
	{
		kpyaw = 10.0f * drft->yawKp;
		kprollpitch = 10.0f * drft->rollPitchKp;
	}

	//Compute proportional correction.
	omegaCorrP[0]=errRollPitch_b[0]*kprollpitch + errYaw_b[0]*kpyaw;
	omegaCorrP[1]=errRollPitch_b[1]*kprollpitch + errYaw_b[1]*kpyaw;
	omegaCorrP[2]=errRollPitch_b[2]*kprollpitch + errYaw_b[2]*kpyaw;
	
	// Compute integral correction. Turn off the offset integrator while spinning at high speeds,
	// it doesn't work in that case, and it only causes trouble.
	if ( normOmegaScalar < MAXIMUM_SPIN_DCM_INTEGRAL )
	{       
		omegaCorrI[0] += (errRollPitch_b[0]*drft->rollPitchKi + errYaw_b[0]* drft->yawKi) * delT;
		omegaCorrI[1] += (errRollPitch_b[1]*drft->rollPitchKi + errYaw_b[1]* drft->yawKi) * delT;
		omegaCorrI[2] += (errRollPitch_b[2]*drft->rollPitchKi + errYaw_b[2]* drft->yawKi) * delT;
	}	
}


/*
 * From Roll-Pitch Gyro Drift Compensation, Rev 3. William Premerlani, 2012.
 */
void rollPitch_drift_GPS(float Rbe[3][3], float accels_e_int[3], float delT_between_updates, float *errRollPitch_b)
{
	float errRollPitch_e[3];
	float dGPSdt_e[3];
	
	GPSVelocityData gpsVelocity;
	GPSVelocityGet(&gpsVelocity);
	
	dGPSdt_e[0]=       (gpsVelocity.North - drft->GPSV_old[0])/delT_between_updates;
	dGPSdt_e[1]=       (gpsVelocity.East  - drft->GPSV_old[1])/delT_between_updates;
	dGPSdt_e[2]=GRAV + (gpsVelocity.Down  - drft->GPSV_old[2])/delT_between_updates;
	
	drft->GPSV_old[0]=gpsVelocity.North;
	drft->GPSV_old[1]=gpsVelocity.East;
	drft->GPSV_old[2]=gpsVelocity.Down;
	
	float normdGPSdt_e=VectorMagnitude(dGPSdt_e);
	
	//Take cross product of integrated accelerometer measurements with integrated earth frame accelerations. We should be using normalized dGPSdt, but we perform that calculation in the following line(s).
	CrossProduct((const float *) accels_e_int, (const float *) dGPSdt_e, errRollPitch_e);
	
	//Scale cross product
	errRollPitch_e[0] /= (normdGPSdt_e*delT_between_updates);
	errRollPitch_e[1] /= (normdGPSdt_e*delT_between_updates);
	errRollPitch_e[2] /= (normdGPSdt_e*delT_between_updates);
	
	//Rotate earth drift error back into body frame;
	rot_mult(Rbe, errRollPitch_e, errRollPitch_b, FALSE);
}


//Values taken from GentleNav
#define MINIMUM_SPIN_RATE_GYRO_CALIB 50.0 // degrees/second
/*
 * At high speeds, the gyro gains can be honed in on. 
 *  Taken from "Fast Rotations", William Premerlani
 */
void calibrate_gyros_high_speed(float gyro[3], float omegaCorrP[3], float normOmegaScalar, float delT, float *ggain)
{
	if ( normOmegaScalar > MINIMUM_SPIN_RATE_GYRO_CALIB )
	{
		float normOmegaVector[3]={gyro[0]/normOmegaScalar, gyro[1]/normOmegaScalar, gyro[2]/normOmegaScalar};	
		
		//Calculate delta gain and update gains
		ggain[0]+=normOmegaVector[0] * omegaCorrP[0]/normOmegaScalar * (glblAtt->gyroGain_ref/drft->gyroCalibTau) * delT;
		ggain[1]+=normOmegaVector[1] * omegaCorrP[1]/normOmegaScalar * (glblAtt->gyroGain_ref/drft->gyroCalibTau) * delT;
		ggain[2]+=normOmegaVector[2] * omegaCorrP[2]/normOmegaScalar * (glblAtt->gyroGain_ref/drft->gyroCalibTau) * delT;
		
		//Saturate gyro gains
		float lowThresh  = 1.0f/1.05f*glblAtt->gyroGain_ref;
		float highThresh = 1.05f*glblAtt->gyroGain_ref;
		for (int i=0;i <3; i++){
			ggain[i]=ggain[i]<lowThresh  ? lowThresh  : ggain[i];
			ggain[i]=ggain[i]>highThresh ? highThresh : ggain[i];
		}
	}
}


/*
 * Although yaw correction is done in horizontal plane, it is 
 *  computed in 3 dimensions, just in case we change our minds later.
 */

void yaw_drift_MagGPS(float Rbe[3][3], bool gpsNewData_flag, bool magNewData_flag, float *errYaw_b)
{
#if defined (PIOS_INCLUDE_GPS) || defined (PIOS_INCLUDE_MAGNETOMETER)

	//      Form the horizontal direction over ground based on rmat
	float horizDirOverGndRmat[3];

	//Define forward vector in earth frame, Rbe' * [1;0;0], and eliminate vertical component from vector
	horizDirOverGndRmat[0]=Rbe[0][0];
	horizDirOverGndRmat[1]=Rbe[0][1];
	horizDirOverGndRmat[2]=0;


 #if defined (PIOS_INCLUDE_GPS)
	if (gpsNewData_flag) {
		
		GPSVelocityData gpsVelocity;
		GPSVelocityGet(&gpsVelocity);

		if ( fabs(gpsVelocity.North) > GPS_SPEED_MIN || fabs(gpsVelocity.East) > GPS_SPEED_MIN)
		{
			float errorGPSYaw_e;
			float errorGPSYaw_b[3];
			float normGPS=sqrtf(gpsVelocity.North*gpsVelocity.North + gpsVelocity.East*gpsVelocity.East);
			float horizDirOverGndGPS[3]={gpsVelocity.North/normGPS, gpsVelocity.East/normGPS, 0}; //Normalized vector
			
			// vector cross product to get the rotation error in ground frame. However, save several processor cycles by 
			// condensing the math to take advantage of the cross products null entries on the x and y elements.
			// errorGPSYaw_e = horizDirOverGndRmat X horizDirOverGndGPS
			errorGPSYaw_e=horizDirOverGndRmat[0]*horizDirOverGndGPS[1] - horizDirOverGndGPS[0]*horizDirOverGndRmat[1];
			
			// Rotate error to body frame. Again, take advantage of the yaw error vector [0;0;errorGPSYaw_e]'s null entries
			// errorGPSYaw_b = Rbe * errorGPSYaw_e;
			errorGPSYaw_b[0]=Rbe[0][2]*errorGPSYaw_e;
			errorGPSYaw_b[1]=Rbe[1][2]*errorGPSYaw_e;
			errorGPSYaw_b[2]=Rbe[2][2]*errorGPSYaw_e;
			
			//Sum error with existing error
			errYaw_b[0] += errorGPSYaw_b[0]*GPS_YAW_KP;
			errYaw_b[1] += errorGPSYaw_b[1]*GPS_YAW_KP;
			errYaw_b[2] += errorGPSYaw_b[2]*GPS_YAW_KP;
		}
	}
 #endif	
	
 #if defined (PIOS_INCLUDE_MAGNETOMETER) //THIS PIOS DEFINE NOT CURRENTLY EXIST, BUT WE SHOULD ADD IT IN ORDER TO SUPPORT ALL MAGS, NOT JUST THE HMC5883
	if (magNewData_flag){
		MagnetometerData magnetometerData;
		MagnetometerGet(&magnetometerData);
		
		
		float errorMagYaw_e;
		float errorMagYaw_b[3];
		float horizDirOverGndMag[3];
		float mags_b[3]={magnetometerData.x, magnetometerData.y, magnetometerData.z};
		
		// Rotate magnetometer to earth frame and eliminate vertical component
		rot_mult(Rbe, mags_b, horizDirOverGndMag, true);
		horizDirOverGndMag[2]=0;
		
		//Compute norm
		float normMag=VectorMagnitude(horizDirOverGndMag);
		
		//Normalize mag_vector. Recall that horizDirOverGndMag[2]=0
		horizDirOverGndMag[0]/=normMag;
		horizDirOverGndMag[1]/=normMag;
		
		// vector cross product to get the rotation error in ground frame. However, save several processor cycles by 
		// condensing the math to take advantage of the cross products null entries on the x and y elements.
		// errorMagYaw_e = horizDirOverGndRmat X horizDirOverGndMag
		errorMagYaw_e=horizDirOverGndRmat[0]*horizDirOverGndMag[1] - horizDirOverGndMag[0]*horizDirOverGndRmat[1];
		
		// Rotate error to body frame. Again, take advantage of the yaw error vector [0;0;errorGPSYaw_e]'s null entries
		// errorMagYaw_b = Rbe * errorMagYaw_e;
		errorMagYaw_b[0]=Rbe[0][2]*errorMagYaw_e;
		errorMagYaw_b[1]=Rbe[1][2]*errorMagYaw_e;
		errorMagYaw_b[2]=Rbe[2][2]*errorMagYaw_e;
		
		errYaw_b[0] += errorMagYaw_b[0]*MAG_YAW_KP;
		errYaw_b[1] += errorMagYaw_b[1]*MAG_YAW_KP;
		errYaw_b[2] += errorMagYaw_b[2]*MAG_YAW_KP;
	}
#endif
#endif	
}

static void GPSVelocityUpdatedCb(UAVObjEvent * objEv)
{
	drft->gpsVelocityDataConsumption_flag=GPS_UNCONSUMED;
}

#if defined (PIOS_INCLUDE_MAGNETOMETER)
static void MagnetometerUpdatedCb(UAVObjEvent * objEv)
{
	drft->magNewData_flag=true;
}
#endif

//static void DCMSettingsUpdatedCb(UAVObjEvent * objEv) {
//	DCMSettingsData dcmSettingsData;	
//	DCMSettingsGet(&dcmSettingsData);
//	
//	drft->accelsKp = dcmSettingsData.accelsKp;
//	drft->rollPitchKp = dcmSettingsData.rollPitchKp;
//	drft->rollPitchKi = dcmSettingsData.rollPitchKi;
//	drft->yawKp = dcmSettingsData.yawKp;
//	drft->yawKi = dcmSettingsData.yawKi;
//	drft->gyroCalibTau = dcmSettingsData.gyroCalibrationTau;
//}

/**
 * @}
 * @}
 */
