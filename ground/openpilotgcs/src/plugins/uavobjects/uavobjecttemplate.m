function [] = OPLogConvert(varargin)
%% Define indices and arrays of structures to hold data
% THIS FILE IS AUTOMATICALLY GENERATED.

outputType='mat'; %Default output is a .mat file

if nargin==0
	%%
	if (exist('uigetfile'))
		[FileName, PathName]=uigetfile('*.opl');
		logfile=fullfile(PathName, FileName);
		
	else
		error('Your technical computing program does not support file choosers. Please input the file name in the argument. ')
	end	
elseif nargin>0
	logfile=varargin{1};
	if nargin>1
		outputType=varargin{2};
	end
end

if ~strcmpi(outputType,'mat') && ~strcmpi(outputType,'csv')
	error('Incorrect file format specified. Second argument must be ''mat'' or ''csv''.');
end

$(ALLOCATIONCODE)


fid = fopen(logfile);
correctMsgByte=hex2dec('20');
correctSyncByte=hex2dec('3C');
unknownObjIDList=zeros(1,2);

% Parse log file, entry by entry
while (1)
	%% Read logging header
	timestamp = fread(fid, 1, '*uint32');
	if (feof(fid)); break; end
	datasize = fread(fid, 1, '*int64');
	
	
	%% Read message header
	% get sync field (0x3C, 1 byte)
	sync = fread(fid, 1, 'uint8');
	if sync ~= correctSyncByte
		disp ('Wrong sync byte');
		return
	end
	% get msg type (quint8 1 byte ) should be 0x20, ignore the rest?
	msgType = fread(fid, 1, 'uint8');
	if msgType ~= correctMsgByte
		disp ('Wrong msgType');
		return
	end
	% get msg size (quint16 2 bytes) excludes crc, include msg header and data payload
	msgSize = fread(fid, 1, 'uint16');
	% get obj id (quint32 4 bytes)
	objID = fread(fid, 1, 'uint32');
	
	if (isempty(objID)) 	%End of file
		break;
	end
	
	%% Read object
	switch objID
$(SWITCHCODE)
		otherwise
			unknownObjIDListIdx=find(unknownObjIDList(:,1)==objID, 1, 'first');
			if isempty(unknownObjIDListIdx)
				unknownObjIDList=[unknownObjIDList; objID 1]; 
			else
				unknownObjIDList(unknownObjIDListIdx,2)=unknownObjIDList(unknownObjIDListIdx,2)+1;
			end
			msgBytesLeft = datasize - 1 - 1 - 2 - 4;
			fread(fid, msgBytesLeft, 'uint8');
	end
	
end

for i=2:size(unknownObjIDList,1) %Don't show the first one, as it was simply a dummy placeholder
   disp(['Unknown object ID: 0x' dec2hex(unknownObjIDList(i,1),8) ' appeared ' int2str(unknownObjIDList(i,2)) ' times.']);
end

%% Clean Up and Save mat file
fclose(fid);

% Trim output structs
$(CLEANUPCODE)

if strcmpi(outputType,'mat')
	[pathstr, name, ext] = fileparts(logfile); 
	save([fullfile(pathstr, name) '.mat'] $(SAVEOBJECTSCODE));
else
$(EXPORTCSVCODE);
end



%% Object reading functions
$(FUNCTIONSCODE)

% This function prunes the excess pre-allocated space
function [structOut]=PruneStructOfArrays(structIn, lastIndex)

	fieldNames = fieldnames(structIn);
	for i=1:length(fieldNames)
		structOut.(fieldNames{i})=structIn.(fieldNames{i})(1:lastIndex);
	end

	
function	OPLog2csv(structIn, structName, logfile)
	%Get each field name from the structure
	fieldNames = fieldnames(structIn);
	
	%Create a text string with the field names
	headerOut=sprintf('%s,',fieldNames{:});
	headerOut=headerOut(1:end-1); %Trim off last `,` and `\t`
	
	%Assign the structure arrays to a matrix.
	matOut=zeros(max(size(structIn.(fieldNames{1}))), length(fieldNames));
	
	if	isempty(structIn.(fieldNames{1}));
		matOut=[];
	else
		for i=1:length(fieldNames)
			matOut(:,i)=structIn.(fieldNames{i});
		end
	end	
	% Create filename by replacing opl by csv
	[path, name] = fileparts(logfile);
	csvDirName=[name '_csv'];
	[dummyA, dummyB]=mkdir(fullfile(path, csvDirName)); %Dummy outputs so the program doens't throw warnings about "Directory already exists"
	csvfile=fullfile(path, csvDirName , [name '.csv']);
	
	%Write to csv.
	dlmwrite(csvfile, headerOut, '');
	dlmwrite(csvfile, matOut, '-append');

